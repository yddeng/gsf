后端开发（Backend）

后端又叫服务器端。网络游戏的大部分业务逻辑都是在后端完成，但实际上游戏的成败和后端的关系比较小，因为它离用户最远，几乎对用户透明。
一个看不见摸不着的东西自然不会对用户的评判有影响。好的服务器端就是让用户感觉不到它的存在，好像在玩一个单机游戏一样，没有网络延迟，
没有卡顿。什么时候服务器端变得不透明了，让用户感觉到了，就是需要优化的时候了。

既然要完成大部分的业务逻辑，首先需要学会一门功能比较完善的综合性语言。在业界主流的后端开发语言是 C++ 和 Java。使用 C++
 是因为它高效的网络处理能力和性能。使用 Java 是因为它的综合实力和低门槛（和 C++ 比）。我个人更偏向于 Java 作为后端语言，
 一是生态圈更加成熟完善（Spring 可能是所有语言的框架中最完善最流行的，而各种大数据工具也多是基于 Java 平台）；二是相对纯粹的面向对象能力进行建模也更加容易；
 三是 Netty 这样的网络框架也能弥补性能上的不足，使开发人员聚焦于业务。C++ 太过强大不易掌控，一旦使用不当反而会出现性能问题，对开发人员的要求也更高。除此之外，
 游戏圈也不乏有其他语言作为后端开发的语言，常见的有 PHP、Node.js、Golang 等。

既然是服务器端开发，就要和服务器打交道，Linux 系统知识、命令、shell 这些东西是必备的技能。它能使你的开发工作更加高效和流畅，是语言外最重要的辅助技能。
网络和协议也是必须要掌握的，前后端如何通讯是一大主 题，需要根据游戏特性选择合理的通讯方式。一个比较复杂的游戏，一般长短链接是都要具备的，协议方面使用 gRPC（protobuf）
、Thrift 是不错的选择，即高效又简洁。也有自己定义二进制协议的，但维护起来相对麻烦。

除语言外，另一个重要的技能就是持久层知识。本质上，前端的工作就是展示数据，后端的工作就是读写数据。几乎所有的所谓业务逻辑，无非就是读出数据攒一个前端需要的扔过去，
或者把用户行为产生的数据保存下来。后端是数据的持有者，如何高效的读写数据就成为后端开发中的重点和难点。所以，对持久层的理解深度就决定了一个后端开发人员水平的高度。
首先，要对使用的主要存储有深入的了解，避免出现使用上的低级错误或性能问题。其次，要学会对不同的业务场景使用不同的存储媒介，合理的存储能极大的简化开发难度。
比如排行榜这种业务直接使用 Redis 的 zset 会比你自己实现高效的多。

后端是数据的生产者，很多数据的消费方都依赖于它，比如 BI。掌握一定的大数据处理工具能让你的技术栈更全面。

第三个重要的技能就是应用服务器本身了。后端程序通常都是以 Web Server 为容器部署的，所以你需要对常用的容器非常了解，比如 Nginx、Tomcat、Apache 等。
另外云服务器的相关使用也需要掌握，现在基本上鲜有部署在实体机房的应用，PaaS 平台是主流。和国内的云服务提供商相比，AWS 有很多自己特有的服务，需要一定的学习曲线。
随着 Kubernetes 的普及，Docker 容器的知识也是后端人员需要掌握的。

最后说说架构设计能力。一方面是设计模式在功能模块中的使用。游戏的业务场景中有大量可以使用设计模式的地方，用好模式可以事半功倍。
另一方面是系统架构的设计。网络游戏必然是一个分布式系统，分布式系统的特性和问题游戏都一样存在。比如弹性设计、性能设计、服务治理、监控等等。
这方面的内容是一个巨大的课题就不展开讲了。一个后端开发工程师要想过渡到架构师就必须具有架构设计的能力。

总结一下后端开发人员的技能树：

精通一门综合性语言，最好是面向对象语言；
持久层知识，深入了解常见的存储系统，比如 MySQL、MongoDB、Redis 等，学会用合理的存储系统组合降低业务开发复杂度；
服务器相关的知识，包括 Linux 系统及命令、Web Server、云服务器、容器等；
系统架构的设计能力，分布式系统、微服务等。
enter image description here

服务器端架构选型
根据游戏的类型、需求不同，服务器端架构也会不同。我个人认为一个比较完善的服务器端架构需要具备下面的功能：

网络通讯及协议：确定游戏使用 HTTP 短连接还是 Socket 长连接和前端交互，协议数据格式使用二进制还是 JSON；
共享数据同步：通过引入分布式缓存等机制实现世界 Boss 这类功能；
通知推送（发布、订阅）能力：任务系统、消息系统等功能需要推送更新；
消息队列：通过它实现数据的异步处理能力；
定时任务系统：每日任务刷新、日更排行榜、奖励、CD 重置等，游戏中大量功能需要定时系统去触发；
逻辑分区；根据时区、地区、用户属性等进行分服、合服的能力；
后台管理：包括玩家信息查询、运营管理、策划数据管理、发布维护等等；
大数据处理：用户行为会产生大量的 BI 数据，用来进行决策和运营活动，大数据处理能力必不可少。包括日志采集、收集汇总，报表等；
灰度发布、A/B Test：游戏中为验证某功能的好坏常常需要进行灰度发布，系统应具有这样的能力；
作为 2C 的互联网产品，游戏有几个非常重要的特点需要考虑到：

可伸缩性：整个系统是弹性的，可伸缩的，且最好能做到自动化。高峰时增加服务器，低谷时减少服务器（AWS 的 auto scaling 可实现这种能力）；
安全性：其一是游戏本身的安全性，即防外挂防作弊，玩家触发的数据都要经过后端验证，且设置警戒线，超过警戒线的数据必然是作弊行为；其二是数据安全性，存储的数据应该有备份，且能够快速恢复；
性能：高并发情况下容易出现性能瓶颈，而游戏通常的瓶颈都在持久层。分库分表、读写分离、多级缓存等是解决持久层性能的主要手段。当然，大前提是代码不能写的太烂，否则神仙都救不了。
下面介绍几种不同划分方式下的架构模型。

按通讯方式划分
短连接通讯
即通过 HTTP 进行前后端的通讯。前端发送请求，后端把 response 结果返回给前端。这种模式其实和大部分互联网产品没有本质区别，通讯层比较轻量级，
一个逻辑上的 Web Server 就可以搞定，易于维护和扩展。基本上可以满足弱联网游戏的需求。比如社交游戏、部分页游、非实时对战的卡牌游戏等。

短连接的情况下前端获取数据都需要用拉（pull）的方式，所以无法将消息主动从服务器推送（push）给客户端。服务器和客户端之间也无法维持状态。
所以，对实时性要求高的游戏，就必须要用长连接的方式了。

长连接通讯
即服务器和客户端维持一个连接不中断。通常底层的通讯协议是 socket。实时性要求高的游戏都必须用长连接进行通讯，因为前后端需要实时的进行数据交互，
数据即可以从前端拉取，也可以从后端推送。比如 MMO 类型的游戏，或者是有实时对战功能的游戏，比如炉石传说、皇室战争；再或者有数据推送的需求，比如全服的广播等。

看上去长连接的能力更强，但也有缺点。因为服务器要和客户端一直保持连接，对系统资源的消耗更大。一台标准配置的服务器能支撑 5000-10000 左右的连接就算很不错了；
用户量越大，服务器集群规模远大于短连接架构，成本也越大。另外技术实现上也相对复杂，处理不当比较容易出现性能问题。

混合型
一个完善的架构会同时具有长短连接的通讯能力，在对应的场景下使用合适的通讯方式。

值得一提的是，有一些功能是2种连接都可以实现的。比如每日任务，即可以通过长连接的方式主动推送刷新任务到前端；也可以使用短连接方式，
当用户进入任务系统界面时发送 HTTP 请求获取任务列表。这样的例子有很多，使用哪种方式需要考虑实现成本。

按网络模式划分
全球同服
顾名思义，游戏只有一个公共的入口，所有进入游戏的玩家都在同一个服，或者说都可以看到、交互。这在早期社交游戏时代是非常普遍的，比如 Zynga 的 CityVille，
你就只能通过 Facebook 这一个入口进入，所有的玩家都可见或产生交互。

随着不同的平台、网络环境的增多，全球同服的概念被弱化了，比如 Android 和 iOS 平台下数据是不互通的，再比如中国版本和国际版本也不能互通（原因你懂）。但这种情况本质上也依然算是同服。

分区分服
分区（zone）一般指的是按照一定属性对数据进行逻辑分离，最常见的就是地区分区，比如暴雪的游戏炉石、星际争霸II，分了台服、国服、美服等；或者根据网络运营商分区，比如电信区、网通区等等。

enter image description here

典型的分服起源于页游时期，同一套游戏程序，不断的部署到新开的服中，服务器之间独立，数据也不互通。通常的策略是一个服的生态较为稳定了，收入也饱和了，
没有多少新增就开新服。在同一个渠道的一组服通常服务器物理上也在一起，和分区的部署不一定相同（分区模式要根据地区选择最优的网络节点）。

enter image description here

和全球同服的模式相比，分区分服模式下各个区、服的数据都是隔离的，不可见的，你是一区的老大，我是二区的老大，互不影响。这也就促成了一种所谓“洗用户”的赚钱方式：
一服玩家差不多了，开新服，继续拉新赚一波，循环往复，这就是为什么能看到很多页游有上百个服的原因。

举例：一个微服务游戏架构
游戏的业务模块和技术模块相对容易分离，非常适合微服务架构。早在微服务流行前，游戏业界的后端架构已经有了模块化的实践，比如分了登录、游戏服务、
场景服务、网关服务、聊天服务等等。下面是我绘制的，并且个人认为比较完整、合理的服务端游戏架构。

enter image description here

通讯层：用来和客户端进行通讯，支撑长短连接，长连接使用 gRPC 方式；
业务层：具体的游戏业务逻辑层，每一个模块都是一个服务，在微服务架构中以独立的进程或者集群方式存在。这里列举了一些常用的公共业务，比如登录服务，用户系统，奖励系统，排行榜、战斗系统等等。
中间层：也可以叫基础服务层，为实现业务模块提供必要的技术层面的支持。比如 HTTP server、socket 框架，分区系统，搜索引擎，消息队列，后台任务，定时任务等等；
持久层：具体的数据存储，包括本地、分布式缓存，数据库（可以是关系型或 NoSQL），CDN 等；
支撑系统：为整个架构系统提供公共的支持服务，比如负载均衡、访问控制、配置管理、日志、统计、监控服务等。
经验分享
上线流程
前端代码打包后就发布到各个渠道了，没有太多后续工作。这里要讲的是后端代码的上线流程。一个比较合理的上线流程应该包括本地环境、开发环境、测试环境、预演环境和生产环境这几个阶段。

enter image description here

本地环境（Local）：程序员自己的本地开发环境，主要完成功能的开发和单元测试；
开发环境（Development）：通常是给前后端集成、联调使用的，本地环境并不稳定，需要有这样一个中立的环境进行集成，或者是 demo 演示；
测试环境（Testing/QA）：Dev环境主要的使用者是前后端程序员，在集成过程中很可能频繁改动，所以如果测试人员使用 Dev 机器进行测试的话，很有可能影响测试的准确率。
比如本来是正常的功能后端重启的服务而 QA 并不知情，就出现了一个不存在的 bug。所以对于一个有正规测试流程的团队来说，测试环境很有必要。如果是很小规模的团队或者是小的游戏，测试环境也可以和 Dev 环境合并；
预演环境（Staging）：一个在架构上和线上环境完全一致的环境，唯一的不同就是集群规模、机器性能、数据量等。线上的架构都是分布式的，
而 Dev 这样的环境因为便捷性的考虑都是一个 all in one 的模式，很多在分布式系统中存在的问题没法在 Dev 环境下测试出来。Staging 是上线流程中最后的一环，相当于守门员，不可或缺。
线上环境（Producation）：最终的生成环境，交付给用户使用。
保证上线流程的完整性非常重要，它能以一个渐进的方式逐步提高代码质量直到交付阶段，是保证游戏尽可能不出现问题的重要手段。

代码安全
代码安全一方面是物理上的安全，即代码是否会被泄漏，被人 copy 走。这方面每个公司都有自己的做法，比如机器没有外网环境，不能使用U盘等（我个人非常唾弃这种缺乏信任的做法）。
这里主要讲逻辑上的安全，即团队协同开发模式下代码在进行 merge 时不会丢失、被覆盖、被删除的问题。

借助 Git 的分支管理能力可以最大限度的保证代码合并的安全性。下面是我比较推荐的一种分支管理方式。

enter image description here

首先，我们有一个 master 主线分支，每个开发周期开始，从它 checkout 出 dev 分支；负责不同功能模块的程序员基于 dev 分支再打出自己的 feature 分支进行开发；
有需要集成和依赖时 merge 回 dev 分支；整个开发周期的开发任务结束并准备上线时，从 dev 分支打出 release 分支，此分支即为线上环境运行的代码，并 merge 回 master。
如果遇到了 bug 需要临时修复，就从 master 拉出一个 hotfix 分支，更新后再 merge 回 master。

通过这样一个科学的分支管理方法，基本上就可以避免代码 merge 上的绝大部分问题。

数据安全
数据可以说是互联网产品最宝贵的资产，特别是用户产生的数据（UGC）。抛开黑客攻击这种问题不谈，我们只讲如何避免操作失误造成的数据丢失问题。

给大家讲一个真实的例子。2010 年左右我还在某 SNS 网站做社交游戏，我们当时有一款品质非常好的农场类游戏，几千万用户，百万级别的 DAU，各方面数据都很稳定。
有一次有个新来不久的同事为了做一些验证测试，打算把自己线上的用户金币数进行调整，于是他在mysql终端中写下了这样的代码：

update user set money = 10000;
不知道是疏忽了还是当时迷糊了，在没有加 where 条件的情况下就回车执行了。对于一个千万量级的表来说这样的更新操作是很慢的，由于经验不足他也没有对半天都没响应的情况深究，
转头去忙别的事。最终的结果，所有的玩家金币被更新成了一样的数量，游戏的经济系统和生态完全崩溃。更倒霉的是数据库的备份是按周而不是按天，只能回滚到一周前的数据。
对于这种数据级的游戏，一周时间在数据上的 gap 是巨大的。整个团队没合眼花了三天两夜通过 log 等各种方式进行数据修复，但结果并不理想。从此之后这款游戏的各项数据指标一路下滑，提早的结束了生命周期。

这样严重的事故告诉我们，需要在以下几个方面建立完善的制度和流程：

权限管理：服务器和数据库的访问权限需要层层设置，逐步收敛到最终负责人；
数据库操作：避免对线上数据的直接操作，如需要可使用从库（slave）替代；重要的写操作需要有人 review；
备份机制：备份的间隔在容许的范围内尽可能短，主从两台是不够的，master 的误操作也会被同步到 slave，还需要单独的 backup 做增量备份（这一点可以参考 MongoDB 的 3 台为一组的 shard 结构）；
日志系统：完善日志，对关键数据的变更进行记录（change history），保证数据可追踪。
线上环境更新与维护
这部分简单介绍一下游戏的更新、新代码部署上线的问题。早期实体服务器没什么特别，老老实实一台台的更新。云服务器下就有了更多选择，主要有 2 种：

滚动式更新：和实体机时代类似，在当前的实例上进行更新操作，通常要依靠脚本进行。这种方式没有实例切换的风险，实例相对稳定；但如果是热更新的话需要新老代码的兼容，保证请求的幂等性。
否则的话要么需要停服维护，要么就没法使用这种方式。
替换式更新：即完全启动一套新的实例，运行新的代码，集群建立完成后通过负载均衡进行网络切换，把流量打到新的集群，完成更新后老集群再 terminate 掉。
这种方式需要先准备好一套新的实例，新实例的稳定性也需要多关注。相对滚动更新来说不容易出错或遗漏，也不用考虑兼容的问题。
另外需要注意的是，热更新，即不停服情况下，一定要注意服务的上下兼容问题；如果是停服更新，避免生硬的强行把用户踢下线，应尽可能做的友好，提前通知，快要停服前进行重复间隔性通知。

故障处理
软件系统出现故障是难免的，本篇最后再介绍一下如何处理故障。

系统恢复的几个方法
重启：重启一般不能根本性的解决问题，但有些情况下确实可以作为一个缓冲之计，为修复争取时间。
回滚：包括代码和数据层面的回滚。快速、简单，解决新上线问题的备用方案，但缺点是会给人带来比较大的挫败感。
降级：暂停出问题的模块，停止服务并告知用户。我们在 LOZ 项目中就使用了降级来保证模块可以 switch off，效果不错。
紧急更新： 大多数正规公司都有繁琐的上线流程。而紧急更新需要勇气和魄力，还需要有强大的自动化部署工具做支持。我个人非常支持这种打破常规的 hotfix，
这是把事故影响范围降低到最小的最快方法。所谓特殊情况特殊对待，和破坏流程的hotfix可能带来的潜在风险相比，不更新是否会导致产品生命周期结束甚至公司蒙受巨大损失？两相权益取其轻。
降低或消除故障的方法
故障演练：这个不多说了，去搜索一下 Netflix 的 Chaos Monkey 你就知道有多牛逼，以及你自己的公司有多 low 逼。
灰度发布：指先小范围的发布，等稳定后再逐步扩大更新范围，减少受影响用户的范围，降低更新风险。有一种是分地区分布，还有一种是 AB Test，根据用户属性对不同的用户执行不同的更新策略甚至是不同的业务逻辑。
比如要上线一个新道具，对尾号单双数的用户使用不同的价格策略，通过收集到的 BI 数据分析哪种定价更加合理。这在游戏行业非常常用。
出现故障是需要复盘的，不能解决完了就完了，要对故障进行分析总结。一般的复盘步骤如下：

找出问题的根源（Root cause），分析出现原因；
总结故障解决步骤，并文档化；
提出改进策略，避免同类问题再次发生。
最后说一下故障的惩罚机制。惩罚和故障本身是没有任何因果关系的，对责任人的惩罚也许根本无法弥补公司受到的损失，带来的后果则是大范围的恐慌情绪，进而影响员工的积极性。
做事就会犯错，为了不受罚，那我干脆不做事打酱油好了。如果员工都抱着这种心态，恐怕公司也没有存活下去的希望了。所以，对于开发人员，故障并不可怕，只要积极面对，
避免同样的错误发生，通过故障不断学习成长才是最重要的。